% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_expand.R
\name{time_expand}
\alias{time_expand}
\alias{time_complete}
\title{A time based extension to \code{tidyr::complete()}.}
\usage{
time_expand(
  data,
  ...,
  time = NULL,
  by = NULL,
  from = NULL,
  to = NULL,
  .by = NULL,
  seq_type = c("auto", "duration", "period"),
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  expand_type = c("nesting", "crossing"),
  sort = TRUE,
  keep_class = TRUE,
  roll_month = "preday",
  roll_dst = "pre",
  log_limit = 8
)

time_complete(
  data,
  ...,
  time = NULL,
  by = NULL,
  from = NULL,
  to = NULL,
  seq_type = c("auto", "duration", "period"),
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  expand_type = c("nesting", "crossing"),
  sort = TRUE,
  .by = NULL,
  keep_class = TRUE,
  fill = NA,
  roll_month = "preday",
  roll_dst = "pre",
  log_limit = 8
)
}
\arguments{
\item{data}{A data frame.}

\item{...}{Groups to expand.}

\item{time}{Time variable.}

\item{by}{Argument to expand and summarise time series.
If \code{by} is \code{NULL} then a heuristic will try and estimate the highest
order time unit associated with the time variable.
If specified, then by must be one of the three:
\itemize{
\item string, specifying either the unit or the number and unit, e.g
\code{by = "days"} or \code{by = "2 weeks"}
\item named list of length one, the unit being the name, and
the number the value of the list, e.g. \code{list("days" = 7)}.
For the vectorized time functions, you can supply multiple values,
e.g. \code{list("days" = 1:10)}.
\item Numeric vector. If by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g \code{by = 1}.
This is also vectorized where applicable.
}}

\item{from}{Time series start date.}

\item{to}{Time series end date.}

\item{.by}{(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.}

\item{seq_type}{If "auto", \code{periods} are used for
the time expansion when days, weeks, months or years are specified, and \code{durations}
are used otherwise.}

\item{floor_date}{Should \code{from} be floored to the nearest unit specified through the \code{by}
argument? This is particularly useful for starting sequences at the beginning of a week
or month for example.}

\item{week_start}{day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default). This is only used when \code{floor_date = TRUE}.}

\item{expand_type}{Type of time expansion to use where "nesting" finds combinations already present in the data,
"crossing" finds all combinations of values in the group variables.}

\item{sort}{Logical. If \code{TRUE} expanded/completed variables are sorted.}

\item{keep_class}{Logical. If \code{TRUE} then the class of the input data is retained.
If \code{FALSE}, which is sometimes faster, a \code{data.table} is returned.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}

\item{log_limit}{The maximum log10 number of rows that can be expanded.
Anything exceeding this will throw an error.}

\item{fill}{A named list containing value-name pairs to fill the named implicit missing values.}
}
\description{
This works much the same as \code{tidyr::complete()}, except that
you can supply an additional \code{time} argument to allow for filling in time gaps,
expansion of time, as well as aggregating time to a higher unit.
\code{lubridate} is used for handling time, while \code{data.table} and \code{collapse} are used for
the data frame expansion.
}
\details{
At the moment, within group combinations are ignored. This means when \code{expand_type = nesting},
existing combinations of supplied groups across the entire dataset are used, and
when \code{expand_type = crossing}, all possible combinations of supplied groups across the \bold{entire}
dataset are used as well.
}
\examples{
\dontrun{
library(timeplyr)
library(lubridate)
library(nycflights13)

data(flights)
x <- flights$time_hour

length(time_missing(x)) # Missing hours
length(missing_dates(x)) # No missing dates though
x_filled <- time_completev(x) # Expand by hour through heuristic
time_missing(x_filled, by  = "hour") # No missing hours

# Easier through tidyverse style functions

flights_count <- flights \%>\%
  fcount(time_hour)

flights_count \%>\%
  time_complete(time = time_hour)

# You can specify units too
flights_count \%>\%
  time_complete(time = time_hour, by = "hour")
flights_count \%>\%
  time_complete(time = as_date(time_hour), by = "day") #  Nothing to complete here

# Where time_expand() and time_complete() really shine is how fast they are with groups
flights \%>\%
  group_by(origin, dest, tailnum) \%>\%
  time_expand(time = time_hour, by = "week",
              seq_type = "duration")
# Alternatively
flights \%>\%
  time_expand(time = time_hour, by = "day",
              .by = c(origin, dest))
}
}
