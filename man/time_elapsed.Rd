% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_elapsed.R
\name{time_elapsed}
\alias{time_elapsed}
\title{Fast grouped time elapsed}
\usage{
time_elapsed(
  x,
  time_by = NULL,
  g = NULL,
  time_type = c("auto", "duration", "period"),
  rolling = FALSE,
  fill = 0
)
}
\arguments{
\item{x}{Date, datetime or numeric vector.}

\item{time_by}{Must be one of the three:
\itemize{
\item string, specifying either the unit or the number and unit, e.g
\code{time_by = "days"} or \code{time_by = "2 weeks"}
\item named list of length one, the unit being the name, and
the number the value of the list, e.g. \code{list("days" = 7)}.
For the vectorized time functions, you can supply multiple values,
e.g. \code{list("days" = 1:10)}.
\item Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g \code{time_by = 1}.
}}

\item{g}{Object to be used for grouping \code{x}, passed onto \code{collapse::GRP()}.}

\item{time_type}{Time type, either "auto", "duration" or "period".
With larger data, it is recommended to use \code{time_type = "duration"} for
speed and efficiency.}

\item{rolling}{If \code{TRUE} then lagged time differences are calculated,
essentially like \code{diff()}. \cr
If \code{FALSE} (the default) then time differences compared to the index (first) time
are calculated.}

\item{fill}{Value with which to fill the first time elapsed value when
\code{rolling = TRUE}.}
}
\description{
Simple function to calculate how much time has passed
on a rolling or fixed basis. \cr
It is extremely efficient for even large numbers of groups, especially
if your data is sorted by those groups.
}
\examples{
library(timeplyr)
library(dplyr)
library(lubridate)
x <- time_seq(today(), length.out = 25, time_by = "3 days")
time_elapsed(x)
time_elapsed(x, rolling = TRUE, time_by = "day")

# Grouped example
set.seed(99)
# ~ 100k groups, 1m rows
x <- sample(time_seq_v2(20, today(), "day"), 10^6, TRUE)
g <- sample.int(10^5, 10^6, TRUE)

time_elapsed(x, time_by = "day", g = g)
# Equivalently (not as efficiently) using dplyr
\dontrun{
tibble(x = x, g = g) \%>\%
  group_by(g) \%>\%
  mutate(elapsed = time_elapsed(x, "day")) \%>\%
  pull(elapsed)
}
}
