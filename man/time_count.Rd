% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_count.R
\name{time_count}
\alias{time_count}
\title{Fast count, fill implicit missing gaps, and (time)
aggregate a time series based data frame.}
\usage{
time_count(
  data,
  ...,
  time = NULL,
  by = NULL,
  from = NULL,
  to = NULL,
  complete = TRUE,
  wt = NULL,
  name = NULL,
  sort = FALSE,
  .by = NULL,
  wide_cols = NULL,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  seq_type = c("auto", "duration", "period"),
  values_fill = NA,
  na_groups = TRUE,
  expand_type = c("nesting", "crossing"),
  roll_month = "preday",
  roll_dst = "pre",
  include_interval = FALSE,
  keep_class = TRUE
)
}
\arguments{
\item{data}{A data frame.}

\item{...}{Additional variables to include.
\code{dplyr} "datamasking" semantics are used.}

\item{time}{Time variable.}

\item{by}{Argument to expand and summarise time series.
If \code{by} is \code{NULL} then a heuristic will try and estimate the highest
order time unit associated with the time variable.
If specified, then by must be one of the three:
\itemize{
\item string, specifying either the unit or the number and unit, e.g
\code{by = "days"} or \code{by = "2 weeks"}
\item named list of length one, the unit being the name, and
the number the value of the list, e.g. \code{list("days" = 7)}.
For the vectorized time functions, you can supply multiple values,
e.g. \code{list("days" = 1:10)}.
\item Numeric vector. If by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g \code{by = 1}.
This is also vectorized where applicable.
}}

\item{from}{Time series start date. If \code{NULL} then min time is used.}

\item{to}{Time series end date. If \code{NULL} then max time is used.}

\item{complete}{Logical. If \code{TRUE} implicit gaps in time are filled
after counting and before time aggregation (through \code{by}).
The default is \code{TRUE}.}

\item{wt}{Frequency weights.
\code{dplyr} "data-masking" is used for variable selection.
Can be \code{NULL} or a variable:
\itemize{
\item If \code{NULL} (the default), counts the number of rows in each group.
\item If a variable, computes \code{sum(wt)} for each group.
}}

\item{name}{Character vector of length 1, specifying the name of
the new column in the output.}

\item{sort}{If \code{TRUE} the groups with largest counts will be sorted first.
If \code{FALSE} the result is sorted by groups + time + ... groups.}

\item{.by}{(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.}

\item{wide_cols}{Variables to pivot into wide format.
To supply multiple variables, use the format \code{c(var1, var2, var3)}.}

\item{floor_date}{Should \code{from} be floored to the nearest unit
specified through the \code{by}
argument? This is particularly useful for starting
sequences at the beginning of a week
or month for example.}

\item{week_start}{day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when \code{floor_date = TRUE}.}

\item{seq_type}{If "auto", \code{periods} are used for
the time expansion when days, weeks, months or
years are specified, and \code{durations}
are used otherwise.}

\item{values_fill}{Value to fill implicit missing values.}

\item{na_groups}{Should rows with missing or \code{NA} groups be kept?}

\item{expand_type}{Type of time expansion to use where
"nesting" finds combinations already present in the data,
"crossing" finds all combinations of values in the group variables.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}

\item{include_interval}{Logical. If \code{TRUE} then
a column "interval" of the form \verb{time_min <= x < time_max} is added
showing the time interval in which the respective counts belong to.
The rightmost interval will always be closed.}

\item{keep_class}{Logical. If \code{TRUE} then the class of
the input data is retained.
If \code{FALSE}, which is sometimes faster, a \code{data.table} is returned.}
}
\value{
An object of class \code{data.frame}
containing the input time variable
which is expanded for each supplied group.
When a grouped_df, or the .by argument is supplied, time expansions are done on a
group-by-group basis.

The \code{by} argument controls the level at which the time variable is expanded/aggregated.
If it is set to "1 month", then a seq of months is created, using the
\code{from} and \code{to} arguments, and every date/datetime is matched to the appropriate
intervals within that sequence. Once they are matched, they are aggregated to the month
level.

To avoid time expansion, simply set \code{complete = FALSE},
which will simply perform a count across your time variable and specified groups.
The time aggregation through \code{by} works even when \code{complete = FALSE} and even when
\code{by} is more granular than the data.
}
\description{
This function operates like \code{dplyr::count()}
but with emphasis on
a specified time variable. This creates an
aggregated frequency time series where
implicit missing gaps in time are filled are
expanded and further aggregated to
both lower and higher levels of time.
It is conceptually a wrapper around \code{count()} and \code{complete()},
but uses data.table for data frame handling,
collapse for grouping calculations,
as well as lubridate and timechange for the time sequence calculations. \cr

An important note is that when the data are grouped, time ranges are expanded
on a group-by-group basis. This works like dplyr where you can supply either a
grouped_df or specify the groupings through \code{.by}.
When groups are supplied through
\code{...}, the time range of the entire data is used for
the expansion of each group.
Depending on the analysis, this may or may not be what you want
and can sometimes result in huge expansions,
so generally it is recommended to
use a grouped_df or supply the additional groups through .\code{by}.

Another important note is that when working with
many groups (>= 500k), period calculations
may be slow and so duration calculations are recommended in this case.
Numeric/duration expansions are
internally vectorised so can easily handle many groups.

If \code{complete = TRUE} then the gaps in the time are expanded.
If \code{by} is supplied, then the time series is aggregated
to this specified level.
}
\examples{
library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

flights <- flights \%>\%
  mutate(date = as_date(time_hour),
         date_num = as.integer(date)) \%>\%
  select(year, month, day, origin, dest, date, time_hour, date_num)

# By default time_count() guesses the time granularity
flights \%>\%
  time_count(time = time_hour)
# Aggregated to week level
flights \%>\%
  time_count(time = date, by = "2 weeks")
flights \%>\%
  time_count(time = date, by = list("months" = 3),
             from = dmy("15-01-2013"),
             floor_date = TRUE,
             include_interval = TRUE)
# By week using numbers
flights \%>\%
  time_expand(time = date_num, by = 7) \%>\%
  mutate(date = as_date(date_num))
}
