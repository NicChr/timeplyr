% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_seq.R
\name{time_seq}
\alias{time_seq}
\alias{time_seq_len}
\alias{time_seq_v}
\title{Time based version of \code{base::seq()} to generate regular time sequences
with additional lubridate functionality for period calculations.}
\usage{
time_seq(
  from,
  to,
  by,
  length.out = NULL,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  seq_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre",
  tz = if (!missing(from)) lubridate::tz(from) else lubridate::tz(to)
)

time_seq_len(
  from,
  to,
  by,
  seq_type = c("auto", "duration", "period"),
  as_period = FALSE
)

time_seq_v(
  from,
  to,
  by,
  seq_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)
}
\arguments{
\item{from}{Start date/datetime of sequence.}

\item{to}{End date/datetime of sequence.}

\item{by}{Unit increment of the sequence.}

\item{length.out}{Length of the sequence.}

\item{floor_date}{Should \code{from} be floored to
the nearest unit specified through the \code{by}
argument? This is particularly useful for
starting sequences at the beginning of a week
or month for example.}

\item{week_start}{day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when \code{floor_date = TRUE}.}

\item{seq_type}{If "auto", \code{periods} are used for
the time expansion when days, weeks,
months or years are specified, and \code{durations}
are used otherwise. If \code{durations}
are used the output is always of class \code{POSIXt}.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}

\item{tz}{Timezone of returned time sequence.}

\item{as_period}{Logical. Should time interval be coerced to a period
before time difference is calculated? This is useful for calculating
for example age in exact years or months.}
}
\description{
This works like \code{seq()},
but using \code{timechange} for the period calculations and
\code{base::seq.POSIXT()} for the duration calculations.
In many ways it is improved over \code{seq.POSIXt()} as
dates and/or datetimes can be supplied with no errors to
the start and end points.
Examples like,\cr
\code{time_seq(now(), length.out = 10, by = "0.5 days", seq_type = "dur")}
and \cr
\code{time_seq(today(), length.out = 10, by = "0.5 days", seq_type = "dur")}\cr
produce more expected results compared to \cr
\code{seq(now(), length.out = 10, by = "0.5 days")} or \cr
\code{seq(today(), length.out = 10, by = "0.5 days")}.\cr

\code{time_seq_v()} is a vectorized version of \code{time_seq()}.\cr

\code{time_seq_len()} is a vectorized convenience
function to calculate the length/size of
a regular time sequence, given a start, end and unit specification.\cr

With periods, impossible dates and datetimes can be
rolled forward or backward
through the \code{roll_month} and \code{roll_dst} arguments.
}
\examples{
library(timeplyr)
library(lubridate)

# Dates
today <- today()
now <- now()

time_seq(today, today + years(1), by = "day")
time_seq(today, length.out = 10, by = "day")
time_seq(today, length.out = 10, by = "hour")

time_seq(today, today + years(1), by = list("days" = 1)) # Alternative
time_seq(today, today + years(1), by = "week")
time_seq(today, today + years(1), by = "fortnight")
time_seq(today, today + years(1), by = "year")
time_seq(today, today + years(10), by = "year")
time_seq(today, today + years(100), by = "decade")

# Datetimes
time_seq(now, now + years(1), by = "12 hours")
time_seq(now, now + years(1), by = "day")
time_seq(now, now + years(1), by = "week")
time_seq(now, now + years(1), by = "fortnight")
time_seq(now, now + years(1), by = "year")
time_seq(now, now + years(10), by = "year")
time_seq(now, today + years(100), by = "decade")

# You can seamlessly mix dates and datetimes with no errors.
time_seq(now, today + days(3), by = "day")
time_seq(now, today + days(3), by = "hour")
time_seq(today, now + days(3), by = "day")
time_seq(today, now + days(3), by = "hour")

# Choose between durations or periods

start <- dmy(31012020)
# If seq_type is left as is,
# periods are used for days, weeks, months and years.
time_seq(start, by = "month", length.out = 12,
         seq_type = "period")
time_seq(start, by = "month", length.out = 12,
         seq_type = "duration")
# Notice how strange base R version is.
seq(start, by = "month", length.out = 12)

# Roll forward or backward impossible dates

leap <- dmy(29022020) # Leap day
end <- dmy(01032021)
# 3 different options
time_seq(leap, to = end, by = "year", seq_type = "per",
         roll_month = "NA")
time_seq(leap, to = end, by = "year", seq_type = "per",
         roll_month = "postday")
time_seq(leap, to = end, by = "year", seq_type = "per",
         roll_month = "preday")
}
