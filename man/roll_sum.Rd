% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roll.R
\name{roll_sum}
\alias{roll_sum}
\alias{roll_mean}
\alias{roll_geometric_mean}
\alias{roll_harmonic_mean}
\alias{roll_apply}
\title{Fast by-group rolling sum/mean}
\usage{
roll_sum(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_geometric_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_harmonic_mean(
  x,
  window = Inf,
  g = NULL,
  partial = TRUE,
  weights = NULL,
  na.rm = TRUE,
  ...
)

roll_apply(x, fun, before = 0L, after = 0L, g = NULL, partial = TRUE)
}
\arguments{
\item{x}{Numeric vector, data frame, or list.}

\item{window}{Rolling window size, default is \code{Inf}.}

\item{g}{Grouping object passed directly to \code{collapse::GRP()}.
This can for example be a vector or data frame.}

\item{partial}{Should calculations be done using partial windows?
Default is \code{TRUE}.}

\item{weights}{Importance weights. Must be the same length as x.
Currently, no normalisation of weights occurs.}

\item{na.rm}{Should missing values be removed for the calculation?
The default is \code{TRUE}.}

\item{...}{Additional arguments passed to \code{data.table::frollmean} and
\code{data.table::frollsum}.}

\item{fun}{A function.}

\item{before}{A number denoting how many indices to look backward on a rolling
basis.}

\item{after}{A number denoting how many indices to look forward on a rolling
basis.}
}
\value{
Excluding \code{roll_apply}, these return a numeric vector the
same length as \code{x} when \code{x} is a vector, and a list when \code{x} is a \code{data.frame}. \cr
\code{roll_apply} returns a list the same length as \code{x}.
}
\description{
An efficient method for rolling sum/mean for many groups. \cr
}
\details{
\code{roll_sum} and \code{roll_mean} support parallel computations when
\code{x} is a data frame of multiple columns. \cr
\code{roll_geometric_mean} and \code{roll_harmonic_mean} are convenience functions that
utilise \code{roll_mean}. \cr
\code{roll_apply} accepts any user function and is more flexible but much
less efficient. It also only accepts vector input. \cr
Please note that \code{roll_apply} and \code{time_roll_apply} are still experimental.
}
\examples{
library(timeplyr)
\dontshow{
data.table::setDTthreads(threads = 2L)
collapse::set_collapse(nthreads = 1L)
}
x <- 1:10
roll_sum(x) # Simple rolling total
roll_mean(x) # Simple moving average
roll_sum(x, window = 3)
roll_mean(x, window = 3)
roll_sum(x, window = 3, partial = FALSE)
roll_mean(x, window = 3, partial = FALSE)

# Plot of expected value of 'coin toss' over many flips
set.seed(42)
x <- sample(c(1, 0), 10^3, replace = TRUE)
ev <- roll_mean(x)
plot(ev)
abline(h = 0.5, lty = 2)

all.equal(roll_sum(iris$Sepal.Length, g = iris$Species),
          ave(iris$Sepal.Length, iris$Species, FUN = cumsum))
# The below is run using parallel computations where applicable
roll_sum(iris[, 1:4], window = 7, g = iris$Species)
\dontrun{
library(data.table)
library(bench)
df <- data.table(g = sample.int(10^5, 10^6, TRUE),
                 x = rnorm(10^6))
mark(e1 = df[, mean := frollmean(x, n = 7, align = "right", na.rm = FALSE), by = "g"]$mean,
     e2 = df[, mean := roll_mean(x, window = 7, g = get("g"), partial = FALSE, na.rm = FALSE)]$mean)
}
}
\seealso{
\link{time_roll_mean} \link{roll_growth_rate}
}
