% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_id.R
\name{group_id}
\alias{group_id}
\alias{add_group_id}
\alias{row_id}
\alias{add_row_id}
\alias{group_order}
\alias{add_group_order}
\title{Fast group and row IDs}
\usage{
group_id(data, ..., order = TRUE, ascending = TRUE, .by = NULL, as_qg = FALSE)

add_group_id(
  data,
  ...,
  order = TRUE,
  ascending = TRUE,
  .by = NULL,
  .name = NULL,
  as_qg = FALSE
)

row_id(data, ..., ascending = TRUE, .by = NULL)

add_row_id(data, ..., ascending = TRUE, .by = NULL, .name = NULL)

group_order(data, ..., ascending = TRUE, .by = NULL)

add_group_order(data, ..., ascending = TRUE, .by = NULL, .name = NULL)
}
\arguments{
\item{data}{A data frame or vector.}

\item{...}{Additional groups using tidy select notation.}

\item{order}{Should the groups be ordered?
\bold{THE PHYSICAL ORDER OF THE DATA IS NOT CHANGED.} \cr
When order is \code{TRUE} (the default) the group IDs will be ordered but not sorted.
If \code{FALSE} the order of the group IDs will be based on first appearance.}

\item{ascending}{Should the group order be ascending or descending?
The default is \code{TRUE}. \cr
For \code{row_id()} this determines if the row IDs are increasing or decreasing. \cr
\bold{NOTE} - When \code{order = FALSE}, the \code{ascending} argument is
ignored. This is something that will be fixed in a later version.}

\item{.by}{Alternative way of supplying groups using tidy
select notation. This is kept to be consistent with other functions.}

\item{as_qg}{Should the group IDs be returned as a
collapse "qG" class? The default (\code{FALSE}) always returns
an integer vector.}

\item{.name}{Name of the added group ID column which should be a
character vector of length 1.
If \code{NULL} then a column named "group_id" will be added,
and if one already exists, a unique name will be used.}
}
\description{
\itemize{
\item \code{group_id()} returns an integer vector of group IDs the same size as the data.
\item \code{add_group_id()} adds an integer column of group IDs.
\item \code{row_id()} returns an integer vector of row IDs.
\item \code{add_row_id()} adds an integer column of row IDs.
\item \code{group_order()} returns the order of the groups.
\item \code{add_group_order()} adds an integer column of the order of the groups.
}

It's important to note that when using \code{data.frames}, these functions by default assume
no groups.
This means that when no groups are supplied:
\itemize{
\item \code{group_id(iris)} returns a vector of ones
\item \code{row_id(iris)} returns the plain row id numbers
\item \code{group_order(iris) == row_id(iris)}.
}

One can specify groups in the second argument like so:
\itemize{
\item \code{group_id(iris, Species)}
\item \code{row_id(iris, dplyr::all_of("Species"))}
\item \code{group_order(iris, contains("width"))}
}
}
\examples{
library(timeplyr)
library(dplyr)
library(ggplot2)
group_id(iris) # No groups
group_id(iris, Species) # Species groups
iris \%>\%
  group_by(Species) \%>\%
  group_id() # Same thing
group_id(iris, where(is.numeric)) # Groups across numeric values

iris \%>\%
  add_group_id(Species) \%>\%
  distinct(Species, group_id)

mm_mpg <- mpg \%>\%
  select(manufacturer, model) \%>\%
  arrange(desc(pick(everything())))

# Sorted/non-sorted groups
mm_mpg \%>\%
  add_group_id(everything(),
               .name = "sorted_id", order = TRUE) \%>\%
  add_group_id(manufacturer, model,
               .name = "not_sorted_id", order = FALSE) \%>\%
  distinct()
}
