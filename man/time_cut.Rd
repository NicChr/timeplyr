% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_cut.R
\name{time_cut}
\alias{time_cut}
\alias{time_breaks}
\title{Cut dates and datetimes into regularly spaced date or datetime intervals}
\usage{
time_cut(
  x,
  n = 5,
  by = NULL,
  fmt = NULL,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  n_at_most = TRUE,
  as_factor = TRUE,
  seq_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)

time_breaks(
  x,
  n = 5,
  by = NULL,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  n_at_most = TRUE,
  seq_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)
}
\arguments{
\item{x}{A date/datetime.}

\item{n}{The minimum number of breaks.}

\item{by}{Argument to expand and summarise time series.
If \code{by} is \code{NULL} then a heuristic will try and estimate the highest
order time unit associated with the time variable.
If specified, then by must be one of the three:
\itemize{
\item string, specifying either the unit or the number and unit, e.g
\code{by = "days"} or \code{by = "2 weeks"}
\item named list of length one, the unit being the name, and
the number the value of the list, e.g. \code{list("days" = 7)}.
For the vectorized time functions, you can supply multiple values,
e.g. \code{list("days" = 1:10)}.
\item Numeric vector. If by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g \code{by = 1}.
This is also vectorized where applicable.
}}

\item{fmt}{(Optional) Date/datetime format for the factor labels.
If supplied, this is passed to \code{format()}.}

\item{floor_date}{Logical. Should the initial date be
floored before building the sequence?}

\item{week_start}{day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default). When \code{label = TRUE},
this will be the first level of the returned factor.}

\item{n_at_most}{Logical. If \code{TRUE} then n breaks at most are returned,
otherwise at least n breaks are returned.}

\item{as_factor}{Logical. If \code{TRUE} the output is an ordered factor.
Setting this to \code{FALSE} is sometimes much faster.}

\item{seq_type}{If "auto", \code{periods} are used for
the time expansion when days, weeks, months or years are specified, and \code{durations}
are used otherwise.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}
}
\description{
\code{time_cut()} is very useful for plotting with dates and datetimes
and always returns breaks of regular width. \cr
To specify exact widths, similar to \code{ggplot2::cut_width()},
supply \code{by} and \code{n = Inf}. \cr
\code{time_breaks()} is a helper that
returns only the time breaks.

By default \code{time_cut()} will try to find
the prettiest way of cutting the interval by
trying to cut the date/datetimes into
groups of the highest possible time units,
starting at years and ending at milliseconds.
If \code{n_at_most = TRUE} then \verb{<= n} groups are calculated,
otherwise \verb{>= n} groups
are calculated.
}
\examples{
library(timeplyr)
library(lubridate)
library(ggplot2)
library(dplyr)

# Easily create custom time breaks
set.seed(8192821)
flights <- nycflights13::flights \%>\%
  slice_sample(n = 10^3) \%>\%
  select(time_hour) \%>\%
  mutate(date = as_date(time_hour))

# time_cut() and time_breaks() automatically find a
# suitable way to cut the data
time_cut(flights$date)
# Works with datetimes as well
time_cut(flights$time_hour, n = 5) # 5 breaks
# Custom formatting
time_cut(flights$date, fmt = "\%Y \%b", by = "month")
time_cut(flights$time_hour, fmt = "\%Y \%b", by = "month")
# Just the breaks
time_breaks(flights$date, n = 5, by = "month")
time_breaks(flights$time_hour, n = 5, by = "month")

# To get exact breaks at regular intervals, use time_expandv
weekly_breaks <- time_expandv(flights$date,
                              by = "5 weeks",
                              week_start = 1, # Monday
                              floor_date = TRUE)
weekly_labels <- format(weekly_breaks, "\%b-\%d")
flights \%>\%
  time_count(time = date, by = "week") \%>\%
  ggplot(aes(x = date, y = n)) +
  geom_bar(stat = "identity") +
  scale_x_date(breaks = weekly_breaks,
               labels = weekly_labels)
}
