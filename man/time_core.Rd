% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_core.R
\name{time_expandv}
\alias{time_expandv}
\alias{time_completev}
\alias{time_summarisev}
\alias{time_countv}
\alias{time_span}
\title{Vector date and datetime functions}
\usage{
time_expandv(
  x,
  by = NULL,
  from = NULL,
  to = NULL,
  seq_type = c("auto", "duration", "period"),
  is_sorted = FALSE,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = "preday",
  roll_dst = "pre"
)

time_completev(
  x,
  by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE,
  seq_type = c("auto", "duration", "period"),
  is_sorted = FALSE,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = "preday",
  roll_dst = "pre"
)

time_summarisev(
  x,
  by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE,
  unique = TRUE,
  seq_type = c("auto", "duration", "period"),
  is_sorted = FALSE,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = "preday",
  roll_dst = "pre",
  include_interval = FALSE
)

time_countv(
  x,
  by = NULL,
  from = NULL,
  to = NULL,
  sort = !is_sorted,
  unique = TRUE,
  use.names = TRUE,
  complete = TRUE,
  seq_type = c("auto", "duration", "period"),
  is_sorted = FALSE,
  floor_date = FALSE,
  include_interval = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = "preday",
  roll_dst = "pre"
)

time_span(
  x,
  by = NULL,
  from = NULL,
  to = NULL,
  seq_type = c("auto", "duration", "period"),
  is_sorted = FALSE,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = "preday",
  roll_dst = "pre"
)
}
\arguments{
\item{x}{Date, datetime or numeric vector.}

\item{by}{Argument to expand and summarise time series.
If \code{by} is \code{NULL} then a heuristic will try and estimate the highest
order time unit associated with the time variable.
If specified, then by must be one of the three:
\itemize{
\item string, specifying either the unit or the number and unit, e.g
\code{by = "days"} or \code{by = "2 weeks"}
\item named list of length one, the unit being the name, and
the number the value of the list, e.g. \code{list("days" = 7)}.
For the vectorized time functions, you can supply multiple values,
e.g. \code{list("days" = 1:10)}.
\item Numeric vector. If by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g \code{by = 1}.
This is also vectorized where applicable.
}}

\item{from}{Time series start date.}

\item{to}{Time series end date.}

\item{seq_type}{If "auto", \code{periods} are used for
the time expansion when days, weeks, months or years are specified,
and \code{durations}
are used otherwise.}

\item{is_sorted}{If \code{TRUE} then x is assumed to be in
ascending order and no additional pre-sorting is done.
It is recommended to leave this as \code{FALSE} unless you require the
extra speed for programming or looping purposes.}

\item{floor_date}{Should \code{from} be floored to the nearest unit specified
through the \code{by}
argument? This is particularly useful for starting sequences
at the beginning of a week
or month for example.}

\item{week_start}{day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when \code{floor_date = TRUE}.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}

\item{sort}{Should the output be sorted? Default is \code{TRUE}.}

\item{unique}{Should the result be unique or match the length of the vector?
Default is \code{TRUE}.}

\item{include_interval}{Logical. If \code{TRUE} then the result is a \code{tibble}
with a column "interval" of the form \verb{time_min <= x < time_max}
showing the time interval in which the aggregated time points belong to.
The rightmost interval will always be closed.}

\item{use.names}{Should a named vector be returned?}

\item{complete}{Logical. If \code{TRUE} implicit gaps in time are filled
before counting and after time aggregation (controlled using \code{by}).
The default is \code{TRUE}.}
}
\description{
These are atomic vector-based functions
of the tidy equivalents which all have a "v" suffix to denote this.
These are more geared towards programmers and allow for working with date and
datetime vectors.
}
\examples{
library(timeplyr)
library(dplyr)
library(lubridate)
flights <- nycflights13::flights
x <- flights$time_hour

n_time_missing(x, by = "hour") # Missing hours
# This returns missing dates, even for datetimes
# where time_missing() returns missing gaps in a date/datetime sequence
missing_dates(x)
# Time sequence that spans the data
time_span(x, by = "hour")
as_datetime(time_span(as.numeric(x), by = 3600), # Also works
            tz = tz(x))
# No need to specify by as it automatically detects granularity
time_span(x)
time_span(x, by = "month")
time_span(x, by = list("quarters" = 1),
             to = today(),
             # Floor start of sequence to nearest month
             floor_date = TRUE)

# Complete missing gaps in time using time_completev
y <- time_completev(x, by = "hour")
all.equal(y[!y \%in\% x], time_missing(x, by = "hour"))

# Summarise time using time_summarisev
time_summarisev(y, by = "quarter")
# Set unique = FALSE to return vector same length as input
time_summarisev(y, by = "quarter", unique = FALSE)
flights \%>\%
  mutate(quarter_start = time_summarisev(time_hour,
                                         by = "quarter",
                                         unique = FALSE)) \%>\%
  fcount(quarter_start)
# You can include the associated time interval
time_summarisev(y, by = "quarter", unique = TRUE,
                include_interval = TRUE)

# Count time using time_countv
time_countv(x, by = list("months" = 3))
time_countv(x, by = list("months" = 3), include_interval = TRUE)

# No completing of missing gaps in time with complete = FALSE
flights \%>\%
  reframe(time = unique(time_hour),
          n = time_countv(time_hour, complete = FALSE,
                          use.names = FALSE))
# With completion
flights \%>\%
  reframe(time = time_expandv(time_hour),
          n = time_countv(time_hour, complete = TRUE,
                          use.names = FALSE))
}
