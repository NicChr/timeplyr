% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_summarise.R
\name{time_summarise}
\alias{time_summarise}
\title{A time based extension to \code{dplyr::summarise()}.}
\usage{
time_summarise(
  data,
  ...,
  time = NULL,
  by = NULL,
  from = NULL,
  to = NULL,
  seq_type = c("auto", "duration", "period"),
  include_interval = FALSE,
  .by = NULL,
  keep_class = TRUE,
  floor_date = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = "preday",
  roll_dst = "pre",
  sort = TRUE
)
}
\arguments{
\item{data}{A data frame.}

\item{...}{Additional variables to include.
\code{dplyr} "datamasking" semantics are used.}

\item{time}{Time variable.}

\item{by}{Argument to expand and summarise time series.
If \code{by} is \code{NULL} then a heuristic will try and estimate the highest
order time unit associated with the time variable.
If specified, then by must be one of the three:
\itemize{
\item string, specifying either the unit or the number and unit, e.g
\code{by = "days"} or \code{by = "2 weeks"}
\item named list of length one, the unit being the name, and
the number the value of the list, e.g. \code{list("days" = 7)}.
For the vectorized time functions, you can supply multiple values,
e.g. \code{list("days" = 1:10)}.
\item Numeric vector. If by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g \code{by = 1}.
This is also vectorized where applicable.
}}

\item{from}{Time series start date.}

\item{to}{Time series end date.}

\item{seq_type}{If "auto", \code{periods} are used for
the time expansion when days, weeks, months or years are specified, and \code{durations}
are used otherwise.}

\item{include_interval}{Logical. If \code{TRUE} then
a column "interval" of the form \verb{time_min <= x < time_max} is added
showing the time interval in which the respective counts belong to.
The rightmost interval will always be closed.}

\item{.by}{(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.}

\item{keep_class}{Logical. If \code{TRUE} then the class of the input data is retained.
If \code{FALSE}, which is sometimes faster, a \code{data.table} is returned.}

\item{floor_date}{Should \code{from} be floored to the nearest unit specified through the \code{by}
argument? This is particularly useful for starting sequences at the beginning of a week
or month for example.}

\item{week_start}{day on which week starts following ISO conventions - 1
means Monday, 7 means Sunday (default). This is only used when \code{floor_date = TRUE}.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}

\item{sort}{Should the result be sorted? Default is \code{TRUE}.
If \code{FALSE} then original (input) order is kept.
The sorting only applies to groups and time variable.}
}
\description{
Unlike the other \code{time_} functions,
\code{time_summarise()} and \code{time_summarisev()} do \bold{not} fill
missing gaps in time. They only summarise dates and datetimes to
higher levels of aggregation.
This works much the same as \code{dplyr::summarise()}, except that
you can supply an additional \code{time} argument to allow for
aggregating time to a higher unit.

Unlike the other \code{time_} functions, this does \bold{not} support
filling in missing gaps in time. Use \code{time_count()} or \code{time_complete()}
before using this if you believe there may be gaps in time.

A good example of why this function might be useful can be seen when
computing summary statistics when there are missing gaps in time.
If you calculated the average number of hourly flights in
the flights dataset, you might do \code{flights \%>\% count(time_hour) \%>\% summarise(avg = mean(n))} which would yield an answer of \code{48.6}
If you instead did
\code{flights \%>\% time_count(time = time_hour) \%>\% summarise(avg = mean(n))}
Or equivalently
\code{flights \%>\% time_count(time = time_hour) \%>\% time_summarise(avg = mean(n), time = time_hour, by = "year")}
Or also
\code{flights \%>\% fcount(time_hour) \%>\% time_complete(time = time_hour, fill = list(n = 0)) \%>\% summarise(avg = mean(n))}
You wold get an answer of 38.5. Why the difference?
The first answers the question: What was the average number of
flights in any hour, for hours where there flights.
The second answers our original question.
}
\examples{
library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

# Works the same way as summarise()
identical(flights \%>\%
            summarise(across(where(is.numeric), mean)),
          flights \%>\%
            time_summarise(across(where(is.numeric), mean)))
# Like the other time_ functions, it allows for an additional time variable to
# aggregate by

# Monthly averages for each numeric variable
flights \%>\%
  time_summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)),
                 time = across(time_hour, as_date),
                 by = "month",
                 include_interval = TRUE)
}
