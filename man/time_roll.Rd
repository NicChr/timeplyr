% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_roll.R
\name{time_roll_sum}
\alias{time_roll_sum}
\alias{time_roll_mean}
\alias{time_roll_window}
\alias{time_roll_window_size}
\title{Fast time-based by-group rolling sum/mean - Currently experimental}
\usage{
time_roll_sum(
  x,
  window,
  time = NULL,
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre",
  ...
)

time_roll_mean(
  x,
  window,
  time = NULL,
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre",
  ...
)

time_roll_window(
  x,
  window,
  time,
  partial = TRUE,
  close_left_boundary = FALSE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)

time_roll_window_size(
  x,
  window,
  partial = TRUE,
  close_left_boundary = FALSE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)
}
\arguments{
\item{x}{Numeric vector.}

\item{window}{Window size, default is \code{length(x)}.
Must be one of the following:
\itemize{
\item string, e.g \code{window = "day"} or \code{window = "2 weeks"}
\item lubridate duration or period object, e.g. \code{days(1)} or \code{ddays(1)}.
\item named list of length one, e.g. \code{list("days" = 7)}.
\item Numeric vector, e.g. \code{window = 7}.
}}

\item{time}{(Optional) time index. \cr
Can be a \code{Date}, \code{POSIXt}, \code{numeric}, \code{integer},
\code{yearmon}, or \code{yearqtr} vector.
If this is left \code{NULL}, a regular rolling sum/mean will be calculated.}

\item{weights}{Importance weights. Must be the same length as x.
Currently, no normalisation of weights occurs.}

\item{g}{Grouping object passed directly to \code{collapse::GRP()}.
This can for example be a vector or data frame.}

\item{partial}{Should calculations be done using partial windows?
Default is \code{TRUE}.}

\item{close_left_boundary}{Should the left boundary be closed?
For example, if you specify \code{window = "day"} and
\code{time = c(today(), today() + 1)}, \cr
a value of \code{FALSE} would result in the window vector \code{c(1, 1)} whereas
a value of \code{TRUE} would result in the window vector \code{c(1, 2)}.}

\item{na.rm}{Should missing values be removed for the calculation?
The default is \code{TRUE}.}

\item{time_type}{If "auto", \code{periods} are used for
the time expansion when lubridate periods are specified or when
days, weeks, months or years are specified,
and \code{durations} are used otherwise.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}

\item{...}{Additional arguments passed to \code{data.table::frollmean} and
\code{data.table::frollsum}.}
}
\description{
An efficient method for a rolling sum/mean for many groups with
respect to a date or datetime time index.
}
\details{
It is much faster if your data are already sorted such that
\code{!is.unsorted(order(g, x))} is \code{TRUE}.
}
\examples{
library(timeplyr)
library(lubridate)
library(dplyr)

time <- time_seq(today(), today() + weeks(3),
                 time_by = "3 days")
set.seed(99)
x <- sample.int(length(time))

roll_mean(x, window = 7)
roll_sum(x, window = 7)

time_roll_mean(x, window = ddays(7), time = time)
time_roll_sum(x, window = days(7), time = time)

# Alternatively and more verbosely
x_chunks <- time_roll_window(x, window = 7, time = time)
x_chunks
purrr::map_dbl(x_chunks, mean)

# Interval [x - 3 x]
time_roll_sum(x, window = ddays(3), time = time,
              close_left_boundary = TRUE)
# Interval (x - 3 x]
time_roll_sum(x, window = ddays(3), time = time,
              close_left_boundary = FALSE)

# An example with an irregular time series

t <- today() + days(sort(sample(1:30, 20, TRUE)))
time_elapsed(t, days(1)) # See the irregular elapsed time
x <- rpois(length(t), 10)

tibble(x, t) \%>\%
  mutate(sum = time_roll_sum(x, time = t, window = days(3))) \%>\%
  time_ggplot(t, sum)

}
