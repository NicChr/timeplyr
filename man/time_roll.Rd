% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_roll.R
\name{time_roll_sum}
\alias{time_roll_sum}
\alias{time_roll_mean}
\alias{time_roll_growth_rate}
\alias{time_roll_window_size}
\alias{time_roll_window}
\alias{time_roll_apply}
\title{Fast time-based by-group rolling sum/mean - Currently experimental}
\usage{
time_roll_sum(
  x,
  window = Inf,
  time = seq_along(x),
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre",
  ...
)

time_roll_mean(
  x,
  window = Inf,
  time = seq_along(x),
  weights = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre",
  ...
)

time_roll_growth_rate(
  x,
  window = Inf,
  time = seq_along(x),
  time_step = NULL,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  na.rm = TRUE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)

time_roll_window_size(
  time,
  window = Inf,
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)

time_roll_window(
  x,
  window = Inf,
  time = seq_along(x),
  g = NULL,
  partial = TRUE,
  close_left_boundary = FALSE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)

time_roll_apply(
  x,
  window = Inf,
  fun,
  time = seq_along(x),
  g = NULL,
  partial = TRUE,
  unlist = FALSE,
  close_left_boundary = FALSE,
  time_type = c("auto", "duration", "period"),
  roll_month = "preday",
  roll_dst = "pre"
)
}
\arguments{
\item{x}{Numeric vector.}

\item{window}{Time window size (Default is \code{Inf}).
Must be one of the following:
\itemize{
\item string, e.g \code{window = "day"} or \code{window = "2 weeks"}
\item lubridate duration or period object, e.g. \code{days(1)} or \code{ddays(1)}.
\item named list of length one, e.g. \code{list("days" = 7)}.
\item Numeric vector, e.g. \code{window = 7}.
}}

\item{time}{(Optional) time index. \cr
Can be a \code{Date}, \code{POSIXt}, \code{numeric}, \code{integer},
\code{yearmon}, or \code{yearqtr} vector.}

\item{weights}{Importance weights. Must be the same length as x.
Currently, no normalisation of weights occurs.}

\item{g}{Grouping object passed directly to \code{collapse::GRP()}.
This can for example be a vector or data frame.}

\item{partial}{Should calculations be done using partial windows?
Default is \code{TRUE}.}

\item{close_left_boundary}{Should the left boundary be closed?
For example, if you specify \code{window = "day"} and
\code{time = c(today(), today() + 1)}, \cr
a value of \code{FALSE} would result in the window vector \code{c(1, 1)} whereas
a value of \code{TRUE} would result in the window vector \code{c(1, 2)}.}

\item{na.rm}{Should missing values be removed for the calculation?
The default is \code{TRUE}.}

\item{time_type}{If "auto", \code{periods} are used for
the time expansion when lubridate periods are specified or when
days, weeks, months or years are specified,
and \code{durations} are used otherwise.}

\item{roll_month}{Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See \code{?timechange::time_add} for more details.}

\item{roll_dst}{See \code{?timechange::time_add} for the full list of details.}

\item{...}{Additional arguments passed to \code{data.table::frollmean} and
\code{data.table::frollsum}.}

\item{time_step}{An optional but \bold{important} argument
that follows the same input rules as \code{window}. \cr
It is currently only used only in \code{time_roll_growth_rate}. \cr
If this is supplied, the time differences across
gaps in time are incorporated into the growth
rate calculation. See \bold{details} for more info.}

\item{fun}{A function.}

\item{unlist}{Should the output of \code{time_roll_apply} be unlisted with
\code{unlist}? Default is \code{FALSE}.}
}
\description{
\code{time_roll_sum} and \code{time_roll_mean} are efficient
methods for calculating a rolling sum and mean respectively given
many groups and with respect to a date or datetime time index. \cr
It is always aligned "right". \cr
\code{time_roll_window} splits \code{x} into windows based on the index. \cr
\code{time_roll_window_size} returns the window sizes for all indices of \code{x}. \cr
\code{time_roll_apply} is a generic function that applies any function
on a rolling basis with respect to a time index.

\code{time_roll_growth_rate} can efficiently calculate by-group
rolling growth rates with respect to a date/datetime index.
}
\details{
It is much faster if your data are already sorted such that
\code{!is.unsorted(order(g, x))} is \code{TRUE}.
\subsection{Growth rates}{

For growth rates across time, one can use \code{time_step} to incorporate
gaps in time into the calculation.

For example: \cr
\code{x <- c(10, 20)} \cr
\code{t <- c(1, 10)} \cr
\code{k <- Inf}\cr
\code{time_roll_growth_rate(x, time = t, window = k)} = \code{c(1, 2)}
whereas \cr
\code{time_roll_growth_rate(x, time = t, window = k, time_step = 1)} = \code{c(1, 1.08)} \cr
The first is a doubling from 10 to 20, whereas the second implies a growth of
8\% for each time step from 1 to 10. \cr
This allows us for example to calculate daily growth rates over the last x months,
even with missing days.
}
}
\examples{
library(timeplyr)
library(lubridate)
library(dplyr)

time <- time_seq(today(), today() + weeks(3),
                 time_by = "3 days")
set.seed(99)
x <- sample.int(length(time))

roll_mean(x, window = 7)
roll_sum(x, window = 7)

time_roll_mean(x, window = ddays(7), time = time)
time_roll_sum(x, window = days(7), time = time)

# Alternatively and more verbosely
x_chunks <- time_roll_window(x, window = 7, time = time)
x_chunks
purrr::map_dbl(x_chunks, mean)

# Interval (x - 3 x]
time_roll_sum(x, window = ddays(3), time = time)

# An example with an irregular time series

t <- today() + days(sort(sample(1:30, 20, TRUE)))
time_elapsed(t, days(1)) # See the irregular elapsed time
x <- rpois(length(t), 10)

tibble(x, t) \%>\%
  mutate(sum = time_roll_sum(x, time = t, window = days(3))) \%>\%
  time_ggplot(t, sum)
\dontrun{
### Rolling mean example with many time series

# Sparse time with duplicates
index <- sort(sample(seq(now(), now() + dyears(3), by = "333 hours"),
                     250, TRUE))
x <- matrix(rnorm(length(index) * 10^5),
            ncol = 10^5, nrow = length(index),
            byrow = FALSE)

zoo_ts <- zoo::zoo(x, order.by = index)

# Say you started with data like zoo_ts
# Normally you might attempt something like this
# apply(zoo_ts, 2,
#       function(x){
#         slider::slide_index_mean(x, i = index, before = dmonths(1))
#       }
# )
# Unfortunately this is too slow and inefficient


# Instead we can pivot it longer and code each series as a separate group
tbl <- ts_as_tibble(zoo_ts)

tbl \%>\%
  mutate(monthly_mean = time_roll_mean(value, window = dmonths(1),
                                time = time, g = group))
}
}
