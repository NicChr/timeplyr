---
title:
output: github_document
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  echo = TRUE,
  collapse = TRUE,
  message = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
```

<!-- badges: start -->
[![R-CMD-check](https://github.com/NicChr/timeplyr/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/NicChr/timeplyr/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

# timeplyr

# **A date and datetime extension to dplyr**

This package provides a set of functions to make working with date and datetime data much easier!

While most time-based packages are designed to work 
with clean and pre-aggregate data, timeplyr contains a set of tidy tools to 
complete, expand and summarise both raw and aggregate date/datetime data.

It introduces no new classes. 

## Installation

You can install and load `timeplyr` using the below code.

```{r gh-installation, message = FALSE, eval = FALSE}
remotes::install_github("NicChr/timeplyr")
```

```{r package_load}
library(timeplyr)
```

## Notes

**All functions that accept a data argument are tidyverse friendly and can handle grouped calculations**


The `time_` functions that accept a data frame argument all operate similarly to the tidyverse equivalents but additionally accept a `time` argument to allow for date/datetime implicit missing value completion, expansion and aggregation.

* `time_count` - Time-based `dplyr::count`
* `time_summarise` - Time-based `dplyr::summarise`
* `time_mutate` - Time-based `dplyr::mutate`
* `time_distinct` - Time-based `dplyr::distinct`
* `time_expand` - Time-based `tidyr::expand`
* `time_complete` - Time-based `tidyr::complete`

For example, `data %>% time_count(time = date, time_by = "month")` will:

  * Fill in missing gaps in time  
  * Count the dates by month

There are many more options to allow for more flexible time summarisation, such as 
choosing start/end times, flooring dates to get full time units (e.g months), and many others.

## Fast functions

There are also a few dplyr alternatives designed to work faster on large numbers of groups.

* `fcount` - `dplyr::count` alternative
* `fdistinct` - `dplyr::distinct` alternative
* `fduplicates` - Finds duplicate rows, similar to `data %>% group_by() %>% filter(n() > 1)`
* `fslice` - `dplyr::slice` alternative

## Vector time functions

There are also vector versions of the tidy equivalents, designed for use on atomic vectors.

These include: 

`time_countv`, `time_expandv`, `time_summarisev` and `time_completev`.

## Convert `ts`, `mts` and `xts` objects to `tibble`

`ts_as_tibble()` easily converts time-series objects into tidy-format.

## zoo

There is lightweight support for zoo's 
`yearmon()` and `yearqtr()` classes.

## Some simple examples

We use flights departing from New York City in 2013.

```{r}
library(tidyverse)
library(lubridate)
library(nycflights13)
flights <- flights %>%
  mutate(date = as_date(time_hour))
```

```{r, echo=FALSE}
theme_set(theme_minimal())
```

## `time_count()`

#### Easily fill in implicit missing gaps and aggregate time.

```{r}
flights_ts <- flights %>%
  time_count(time_hour)
flights_ts
```


#### Dates work as easily as datetimes

```{r}
flights %>%
  time_count(date, time_by = "day")
```

#### Specify time aggregation through `time_by`

```{r}
# Some examples
flights %>%
  time_count(date, time_by = "7 days")
flights %>%
  time_count(date, time_by = "2 weeks")
flights %>%
  time_count(date, time_by = "fortnight")
flights %>%
  time_count(date, time_by = "month")
flights %>%
  time_count(date, time_by = "quarter")
flights %>%
  time_count(date, time_by = "year")
```

#### Ensure full weeks/months/years by using `time_floor = TRUE`

```{r}
start <- dmy("17-Jan-2013")
flights %>%
  time_count(date,
             time_by = "week", from = start, time_floor = TRUE)
flights %>%
  time_count(date,
             time_by = "month", from = start, time_floor = TRUE)
```

## `missing_dates()`

#### Check for missing gaps in time

```{r missing_dates}
missing_dates(flights) # No missing dates
```

```{r}
time_num_gaps(flights$time_hour, time_by = "hours") # Missing hours
```

#### Alternatively, counts with `time_countv()`

```{r}
flight_counts <- time_countv(flights$time_hour, time_by = "hour")
flights_ts %>%
  mutate(n2 = flight_counts)
```

## `time_expand()`

All the `time_` functions with a data argument work with groups.
Here we create a weekly time sequence for each origin and destination

```{r}
origin_dest_seq <- flights %>%
  group_by(origin, dest) %>%
  time_expand(date, time_by = "week")
```

Another thing to note is that all `time_` functions have a 
`time_type` argument to let you specify if you want durations or periods.
By default it is "auto" which chooses periods for time units 
greater or equal to days and durations otherwise.

```{r}
start <- dmy("01-01-2023")
time_seq(start, start + years(1), 
         time_by = "month",
         time_type = "period")
time_seq(start, start + years(1), 
         time_by = "month",
         time_type = "duration")
```

When you supply groups to `time_expand()` 
the start and end points are unique to each group.
We confirm this below

```{r}
origin_dest_seq %>%
  summarise(from = min(date),
            to = max(date)) %>%
  ungroup() %>%
  distinct(from, to, .keep_all = TRUE)
```

The ability to create time sequences by group is 
one of the most powerful features of timeplyr.

## `time_complete()`

#### We could instead use `fcount()` and `time_complete()` to
#### count the hours with no gaps.

```{r}
flights %>%
  group_by(origin, dest) %>%
  fcount(time_hour) %>%
  time_complete(time_hour, 
                time_by = "hour", 
                fill = list(n = 0))
```

## `time_span()`

`time_span()` or `time_expandv()` is a vector-based version of `time_expand()`
that allows you to create full time sequences for time data

```{r}
flights %>%
  group_by(origin) %>%
  reframe(time_hour = time_span(time_hour, "quarter"))
```

## `time_summarise()`

We can do more than just counts, actually any summary using `time_summarise()`
We can for example, calculate mean arrival and departure times by month

```{r}
flights %>%
  time_summarise(time_hour, # Time variable 
                 across(c(arr_time, dep_time), # By-month summaries
                        ~ mean(.x, na.rm = TRUE)),
                 time_by = "month",   
                 time_floor = TRUE, # Full months
                 include_interval = TRUE) # Time interval
```

## `time_mutate()`

A time-based version of mutate

```{r}
flights %>%
  time_mutate(date, time_by = "quarter", .keep = "none") %>%
  fcount(date)
```

## `add_calendar()`

#### Easily join common date information to your data

```{r}
flights_ts <- flights_ts %>%
  add_calendar(time_hour)
```

Now that gaps in time have been filled and we have 
joined our date table, it is easy to count by any time dimension we like

```{r}
flights_ts %>% 
  fcount(isoyear, isoweek, wt = n)
flights_ts %>% 
  fcount(isoweek = iso_week(time_hour), wt = n)
flights_ts %>% 
  fcount(month_l, wt = n)
```

### Other convenience functions are included below

## `.time_units`

See a list of available time units

```{r}
.time_units
```

## `age_years()`

Calculate ages (years) accurately

```{r}
age_years(dmy("28-02-2000"))
```

## `time_seq()`

A lubridate version of `seq()` for dates and datetimes

```{r}
start <- dmy(31012020)
end <- start + years(1)
seq(start, end, by = "month") # Base R version
time_seq(start, end, time_by = "month") # lubridate version

```

`time_seq()` doesn't mind mixing dates and datetimes

```{r}
time_seq(start, as_datetime(end), time_by = "2 weeks")
```

## `time_seq_v()`

A vectorised version of `time_seq()`
Currently it is vectorised over from, to and by

```{r}
# 3 sequences
time_seq_v(from = start, 
           to = end, 
           time_by = list("months" = 1:3))
# Equivalent to 
c(time_seq(start, end, time_by = "month"),
  time_seq(start, end, time_by = "2 months"),
  time_seq(start, end, time_by = "3 months"))
```

## `time_seq_sizes()`
Vectorised function that calculates time sequence lengths

```{r}
seq_lengths <- time_seq_sizes(start, start + days(c(1, 10, 20)), 
                              time_by = list("days" = c(1, 5, 10)))
seq_lengths

# Use time_seq_v2() if you know the sequence lengths
seqs <- time_seq_v2(seq_lengths, start, time_by = list("days" = c(1, 5, 10)))
seqs
```

## Extra: Use `seq_id()` to name the unique sequences

```{r}
names(seqs) <- seq_id(seq_lengths)
tibble::enframe(seqs)
```

Dealing with impossible dates and datetimes is very simple

```{r}
time_seq(start, end, time_by = "month", roll_month = "postday") # roll impossible months forward
time_seq(start, end, time_by = "month", roll_month = "NA") # no roll

time_seq(start, end, time_by = "month", time_type = "duration") # lubridate version with durations
```

## time-series (`ts`)

Easily turn `ts` objects into `tibbles`

```{r}
air_tbl <- ts_as_tibble(AirPassengers)
```

# Plot using `time_ggplot()`

```{r}
air_tbl %>%
  time_ggplot(time, value)
```

Multivariate time-series are converted into long-format

```{r}
eu_stock_tbl <- ts_as_tibble(EuStockMarkets)

eu_stock_tbl %>%
    time_ggplot(time, value, group)
```

## `iso_week()`

Simple function to get formatted ISO weeks.

```{r}
iso_week(today())
iso_week(today(), day = TRUE)
iso_week(today(), year = FALSE)
```

Helpers like `calendar()`, `create_calendar()` and `add_calendar()` can make time sequence tibbles.

```{r}
my_seq <- time_seq(start, end, "day")
calendar(my_seq)
create_calendar(start, end, "day") # The same style as time_seq
# Tidy version
tibble(my_seq) %>%
  add_calendar(my_seq)
```

## `time_cut()`

Create pretty time axes using `time_cut()` and `time_breaks()`

```{r}
times <- flights$time_hour
dates <- flights$date

levels(time_cut(dates, n = 10))
date_breaks <- time_breaks(dates, n = 12)
time_breaks <- time_breaks(times, n = 12, time_floor = TRUE)

weekly_data <- flights %>%
  time_count(time = date, time_by = "week",
             to = max(time_span(date, time_by = "week")),
             include_interval = TRUE) %>%
  # Filter full weeks
  mutate(n_days = interval/days(1)) %>%
  filter(n_days == 7)
weekly_data %>%
  ggplot(aes(x = date, y = n)) + 
  geom_bar(stat = "identity", fill = "#0072B2") + 
  scale_x_date(breaks = date_breaks, labels = scales::label_date_short())

flights %>%
  ggplot(aes(x = time_hour)) + 
  geom_bar(fill = "#0072B2") + 
  scale_x_datetime(breaks = time_breaks, labels = scales::label_date_short())
```

## Efficient grouped functions

## `group_collapse()`

Collapse your data into unique groups with key information

```{r}
flights %>%
  group_collapse(origin, dest)
# Sorted (like dplyr::group_data())
flights %>%
  group_collapse(origin, dest, sort = TRUE)
# By order of first appearance
flights %>%
  group_collapse(origin, dest, order = FALSE)
```

## `fcount()`/`fadd_count()`

```{r}
flights %>%
  fgroup_by(origin, dest, tailnum) %>%
  fcount(flight, carrier)
flights %>%
  fselect(origin, dest, tailnum, flight, carrier) %>%
  fadd_count(across(all_of(c("flight", "carrier"))), 
             .by = c(origin, dest, tailnum))
  
```

## `group_id()`/`add_group_id()`

This calculates sorted and non-sorted group IDs

```{r}
flights %>%
  fgroup_by(origin, dest) %>%
  group_id(order = FALSE) %>%
  unique()
flights %>%
  fselect(origin, dest) %>%
  add_group_id(.by = everything()) %>%
  fdistinct(origin, dest, group_id)
```

## `fexpand()`

Fast cross join

```{r}
# Tidy version that supports groups
flights %>%
  fgroup_by(origin) %>%
  fexpand(dest, carrier)
```

## `fslice()`

Fast row index slicing with lots of groups

```{r}
flights %>%
  fgroup_by(origin, dest, tailnum) %>%
  fslice(1:5)
flights %>%
  fgroup_by(origin, dest, tailnum) %>%
  fslice_head(n = 5)
# Use keep_order to retain the data input order
flights %>%
  fgroup_by(origin, dest, tailnum) %>%
  fslice_tail(prop = 0.5, keep_order = TRUE)
```

## `fdistinct()`

Distinct rows

```{r}
flights %>%
  fgroup_by(origin, dest, tailnum) %>%
  fdistinct(year, month, day)
```

## `fduplicates()`

Duplicate rows

```{r}
flights %>%
  fgroup_by(origin, dest, tailnum) %>%
  fduplicates(year, month, day)
```

## `row_id()`/`add_row_id()`

Fast grouped row IDs

```{r}
iris <- as_tibble(iris)
range(row_id(iris))
iris %>%
  add_row_id()
iris %>% 
  add_row_id(Species)
```

## `stat_summarise()` 

Fast Grouped statistical functions

```{r}
# This is extremely fast and efficient, especially with lots of groups
flights %>%
  stat_summarise(arr_time, .by = origin, stat = c("n", "mean", "min", "max"))
```

## `q_summarise()`

# Fast grouped quantiles

```{r}
flights %>%
  q_summarise(arr_time, .by = tailnum)

# Pivot longer for data wrangling or plotting
flights %>%
  q_summarise(arr_time, .by = origin, 
              pivot = "long")
```


