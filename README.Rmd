---
title:
output: github_document
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  echo = TRUE,
  collapse = TRUE,
  message = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
```

<!-- badges: start -->
[![R-CMD-check](https://github.com/NicChr/timeplyr/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/NicChr/timeplyr/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

# timeplyr

# **A date and datetime extension to dplyr**

This package provides a set of functions for
wrangling, completing and summarising date and datetime data.

**It introduces no new classes to learn.**

## Installation

You can install and load `timeplyr` using the below code.

```{r gh-installation, message = FALSE, eval = FALSE}
remotes::install_github("NicChr/timeplyr")
```

```{r package_load}
library(timeplyr)
```

## Notes

**All functions that accept a data argument are tidyverse friendly**

**All functions that accept a data argument can handle grouped calculations**

**Most functions with a v suffix are vector versions of the tidy equivalents**


The functions `time_count()`, `time_expand()`, `time_summarise()`, `time_complete()`, `time_mutate()` and `time_reframe()`
all operate similarly to the tidyverse equivalents but additionally accept a `time` argument.  

For example, `data %>% time_count(time = date, by = "month")` will:

  * Fill in missing gaps in time  
  * Count the dates by month

There are many more options to allow for more flexible time summarisation, such as 
choosing start/end times, flooring dates to get full time units (e.g months), and many others.

## Some simple examples

We use flights departing from New York City in 2013.

```{r}
library(tidyverse)
library(lubridate)
library(nycflights13)
flights <- flights %>%
  mutate(date = as_date(time_hour))
```

## `time_count()`

#### Easily fill in implicit missing gaps and aggregate time.

```{r}
flights_ts <- flights %>%
  time_count(time = time_hour)
flights_ts
```


#### Dates work as easily as datetimes

```{r}
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "day")
```

#### Specify time aggregation through `by`

```{r}
# Some examples
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "7 days")
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "2 weeks")
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "fortnight")
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "month")
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "quarter")
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "year")
```

#### Ensure full weeks/months/years by using `floor_date = TRUE`

```{r}
start <- dmy("17-Jan-2013")
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "week", from = start, floor_date = TRUE)
flights %>%
  time_count(time = across(time_hour, as_date),
             by = "month", from = start, floor_date = TRUE)
```

## `missing_dates()`

#### Check for missing gaps in time

```{r missing_dates}
missing_dates(flights) # No missing dates
length(time_missing(flights$time_hour, by = "hour")) # Missing hours
time_missing(flights$date, by = "day") # Missing days
```

#### Alternatively, counts with `time_countv()`

```{r}
flight_counts <- time_countv(flights$time_hour, by = "hour")
flights_ts %>%
  mutate(n2 = flight_counts)
```

## `time_expand()`

All the `time_` functions with a data argument work with groups.
Here we create a weekly time sequence for each origin and destination

```{r}
origin_dest_seq <- flights %>%
  group_by(origin, dest) %>%
  time_expand(time = date, by = "week")
```

Another thing to note is that all `time_` functions have a 
`seq_type` argument to let you specify if you want durations or periods.
By default it is "auto" which chooses periods for time units 
greater or equal to days and durations otherwise.

```{r}
start <- dmy("01-01-2023")
time_seq(start, start + years(1), 
         by = "month",
         seq_type = "period")
time_seq(start, start + years(1), 
         by = "month",
         seq_type = "duration")
```

When you supply groups to `time_expand()` 
the start and end points are unique to each group.
We confirm this below

```{r}
origin_dest_seq %>%
  summarise(from = min(date),
            to = max(date)) %>%
  ungroup() %>%
  distinct(from, to, .keep_all = TRUE)
```

The ability to create time sequences by group is 
one of the most powerful features of timeplyr.

## `time_complete()`

#### We could instead use `fcount()` and `time_complete()` to
#### count the hours with no gaps.

```{r}
flights %>%
  group_by(origin, dest) %>%
  fcount(time_hour) %>%
  time_complete(time = time_hour, 
                by = "hour", 
                fill = list(n = 0))
```

## `time_span()`

#### Alternatively using `time_span()` and `fcomplete()`

```{r}
hour_seq <- time_span(flights$time_hour, by = "hour")
flights %>%
  group_by(origin, dest) %>%
  fcount(time_hour) %>%
  fcomplete(time_hour = hour_seq,
            fill = list(n = 0))
```

#### The above has the same expanded time sequence for each group and
#### can be achieved using `time_count()` as well

```{r}
flights %>%
  time_count(origin, dest, time = time_hour, by = "hour")
```

## `add_calendar()`

#### Easily join common date information to your data

```{r}
flights_ts <- flights_ts %>%
  add_calendar(time_hour)
```

Now that gaps in time have been filled and we have 
joined our date table, it is easy to count by any time dimension we like

```{r}
flights_ts %>% 
  fcount(isoyear, isoweek, wt = n)
flights_ts %>% 
  fcount(isoweek = iso_week(time_hour), wt = n)
flights_ts %>% 
  fcount(month_l, wt = n)
```

#### To ensure full weeks, set `floor_date = TRUE` and `by = "week"`.

```{r}
flights %>%
  time_count(time = time_hour,
             by = "week", 
             floor_date = TRUE)
```

## `time_summarise()`

We can do more than just counts, actually any summary using `time_summarise()`
We can for example, calculate mean arrival and departure times by month

```{r}
flights %>%
  time_summarise(across(c(arr_time, dep_time), 
                        ~ mean(.x, na.rm = TRUE)),
                 time = time_hour, 
                 by = "month",  
                 floor_date = TRUE,
                 include_interval = TRUE)
```

## `time_mutate()`

A time-based version of mutate

```{r}
flights %>%
  time_mutate(time = date, by = "quarter",
              .keep = "none") %>%
  fcount(date)
```

### Other convenience functions are included below

## `.time_units`

See a list of available time units

```{r}
.time_units
```

## `age_years()`

Calculate ages (years) accurately

```{r}
age_years(dmy("28-02-2000"))
```

## `time_seq()`

A lubridate version of `seq()` for dates and datetimes

```{r}
start <- dmy(31012020)
end <- start + years(1)
seq(start, end, by = "month") # Base R version
time_seq(start, end, by = "month") # lubridate version

```

`time_seq()` doesn't mind mixing dates and datetimes

```{r}
time_seq(start, as_datetime(end), by = "2 weeks")
```

## `time_seq_v()`

A vectorised version of `time_seq()`
Currently it vectorised over from, to and num

```{r}
# 3 sequences
time_seq_v(from = start, 
           to = end, 
           units = "months", 
           num = 1:3)
# Equivalent to 
c(time_seq(start, end, by = "month"),
  time_seq(start, end, by = "2 months"),
  time_seq(start, end, by = "3 months"))

```

## `time_seq_len()`
Vectorised function that calculates time sequence lengths

```{r}
time_seq_len(start, start + years(1:10), 
             by = list("days" = sample(1:10)))
```

Dealing with impossible dates and datetimes is very simple

```{r}
time_seq(start, end, by = "month", roll_month = "postday") # roll impossible months forward
time_seq(start, end, by = "month", roll_month = "NA") # no roll

time_seq(start, end, by = "month", seq_type = "duration") # lubridate version with durations
```

## `iso_week()`

Simple function to get formatted ISO weeks.

```{r}
iso_week(today())
iso_week(today(), day = TRUE)
iso_week(today(), year = FALSE)
```

Helpers like `calendar()`, `create_calendar()` and `add_calendar()` can make time sequence tibbles.

```{r}
my_seq <- time_seq(start, end, by = "day")
calendar(my_seq)
create_calendar(start, end, by = "day") # The same style as time_seq
# Tidy version
tibble(my_seq) %>%
  add_calendar(my_seq)
```

## `time_cut()`

Create pretty time axes using `time_cut()` and `time_breaks()`

```{r}
times <- flights$time_hour
dates <- flights$date

levels(time_cut(dates, n = 10))
date_breaks <- time_breaks(dates, n = 12)
time_breaks <- time_breaks(times, n = 12, floor_date = TRUE)

weekly_data <- flights %>%
  time_count(time = date, by = "week",
             to = max(time_span(date, by = "week")),
             include_interval = TRUE) %>%
  # Filter full weeks
  mutate(n_days = interval/days(1)) %>%
  filter(n_days == 7)
weekly_data %>%
  ggplot(aes(x = date, y = n)) + 
  geom_bar(stat = "identity", fill = "#0072B2") + 
  scale_x_date(breaks = date_breaks, labels = scales::label_date_short()) +
  theme_minimal()

flights %>%
  ggplot(aes(x = time_hour)) + 
  geom_bar(fill = "#0072B2") + 
  scale_x_datetime(breaks = time_breaks, labels = scales::label_date_short())
```

